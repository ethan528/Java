# Java

## 클래스와 객체

클래스로 객체 정의 및 생성

객체 = 속성(변수) + 기능(메서드)

객체 = 모든 인스턴스

인스턴스 = 특정 클래스로 생성된 객체

인스턴스화 = 클래스 > 인스턴스(객체)

소스파일명은 public class 명과 일치해야 함

하나의 소스파일엔 하나의 public class 만 존재

## 객체 생성

`클래스 참조 변수 = new 인스턴스();`

`변수.변수 = ;`

`변수.메서드();`

다수의 참조 변수로 하나의 인스턴스 참조 가능

`참조 변수 = 참조 변수;`

## 객체 배열

### 1

```aidl
클래스 참조 배열[] = new 인스턴스[];

참조 배열[0] = new 인스턴스();

참조 배열[1] = new 인스턴스();

참조 배열[2] = new 인스턴스();
```

### 2

- `클래스 참조 배열[] = {new 인스턴스(), new 인스턴스(), new 인스턴스()};`

## 클래스란

클래스 = 데이터 + 함수

## 선언 위치에 따른 변수 종류

### 클래스 영역 = 선언문만 가능

- iv(instance variable) = 인스턴스가 생성되었을 때 생성

- cv(class variable) = static + iv 형태, 클래스가 메모리에 올라갈 때 생성

### 메서드 영역

- lv(local variable) = 변수 선언문이 수행되었을 때 생성, 메서드 종료시 사용 불가

## 클래스 변수와 인스턴스 변수

### 인스턴스 변수

- 개별 속성

- `클래스 참조변수 = new 인스턴스();`

- 객체 생성과 비례해 생성

### 클래스 변수

- 공통 속성

```aidl
// 참조 변수도 사용 가능하나 권장하지 않음
클래스 참조 변수 = new 인스턴스();

//권장하는 방법
클래스.속성 이름 = 값;
```

- 1개만 존재

- 객체 생성없이 사용 가능, 자동으로 생성

## 메서드란?

문장들을 묶어 놓은 것

중복된 코드를 메서드로 변환해 메서드 호출을 통해 코드 간결화

작업단위로 문장들을 묶어서 이름 붙인 것

```aidl
반환 타입 메서드 이름 (타입 매개변수1, 타입 매개변수2) {
    타입 반환값 = 매개변수1 + 매개변수2;
    return 반환값;
}
```

## 메서드 호출

메서드 호출 방법 = `메서드 이름(값1, 값2)`

메서드는 클래스 영역에만 정의 가능

## return 문

실행 중인 메서드를 중지하고 호출한 곳으로 복귀

반환 타입이 void 인 경우 생략 가능

if 문의 경우 참과 거짓의 두 가지 경우의 return 문이 필요

메서드의 반환 타입과 반환값의 반환 타입 일치

## 호출 스택(call stack)

FILO = First In Last Out, 선입 후출

## 기본형 매개변수

변수 값 읽기만 가능(Read only)


## 참조형 매개변수

변수 값 읽고 변경 가능(Read and write)

반환 타입이 참조형인 경우 객체의 주소 반환

같은 클래스 안 or static 메서드 = 참조 변수 없이 호출 가능

## static 메서드와 인스턴스 메서드

### static 메서드(클래스 메서드)

- 객체 생성 없이 `클래스 이름.메서드 이름();`으로 호출

- 메서드 안에서 인스턴스 변수 사용 불가

- 클래스 변수는 사용 가능

- 인스턴스 메서드 호출 불가

### 인스턴스 메서드

- 인스턴스 생성 후 `참조 변수. 메서드 이름();`으로 호출

- 메서드 안에서 인스턴스 변수 사용 가능

### static 을 붙이는 기준

- 인스턴스 변수를 사용하지 않는 메서드

- 속성 중 공통 속성

## 오버로딩(Overloading)

한 클래스 안에 같은 이름의 메서드 여러 개를 정의한 것

### 오버로딩 성립 조건

- 메서드 이름이 같아야 한다

- 매개변수의 개수 또는 타입이 달라야 한다

- 반환 타입은 영향이 없다

메서드 이름 = 대부분 동사

## 생성자(constructor)

인스턴스가  생성될 때마다 호출되는 '인스턴스 초기화 메서드'

`클래스 이름 참조 변수 = new 생성자();`

생성자의 이름은 클래스와 같아야 함

리턴값이 없다(void 안 붙임)

모든 클래스는 1개 이상의 생성자가 있어야 함

### 기본 생성자(default constructor)

- 매개변수가 없는 생성자

- 생성자가 하나도 없을 때만 컴파일러가 자동 추가

- 기본 생성자는 만드는 게 원칙

- `클래스 이름() {}`

- 기본 생성자 없이 매개변수가 있는 생성자가 있을 경우 에러 발생

### 매개변수가 있는 생성자

```aidl
클래스 이름 {
    타입 변수1
    타입 변수2
    
    생성자() {} // 기본 생성자
    생성자(타입 변수3, 타입 변수4) { // 매개변수가 있는 생성자
        변수1 = 변수3;
        변수2 = 변수4;
    }
}    
```

- 매개변수가 있을 경우 코드가 더 간결해짐

```aidl
// 매개변수가 있는 생성자가 없을 경우
클래스 이름 참조 변수 = new 생성자();
참조 변수.변수1 = 값1;
참조 변수.변수2 = 값2;

// 매개변수가 있는 생성자가 있을 경우
클래스 이름 참조 변수 = new 생성자(값1, 값2);
```

- `클래스 이름 참조 변수 = new 생성자();`

- 클래스 이름 참조 변수 = 참조 변수 생성

- new = 객체 생성

- 생성자() = 생성자 호출 후 객체 초기화

## 생성자 this()

같은 클래스에 생성자 안에서 다른 생성자를 호출할 때 사용

첫 줄에서만 사용 가능

## 참조 변수 this

인스턴스 자신을 가리키는 참조 변수

인스턴스 메서드에서만 사용 가능

지역 변수와 인스턴스 변수를 구별할 때 사용

this. 이 붙으면 인스턴스 변수

같은 클래스 안에선 생략 가능

이름이 같을 경우 생략 불가

인스턴스 주소 저장되어 있음

선언 안 해도 사용 가능

## 변수의 초기화

지역 변수는 수동 초기화 해야 함

멤버 변수(인스턴스 변수, 클래스 변수)는 자동 초기화 됨

## 멤버 변수의 초기화

명시적 초기화(=) = 선언 시 대입 연산자를 통해 초기화

### 초기화 블럭 = 복잡한 초기화 시 사용

- 인스턴스 초기화 블럭 = {}

- 클래스 초기화 블럭 = static {}

생성자 = 복잡한 초기화 시 사용

인스턴스 변수 초기화 = 생서앚

클래스 변수 초기화 = static {}

클래스 변수 초기화 시점 = 클래스가 처음 로딩될 때 한 번

인스턴스 변수 초기화 시점 = 인스턴스가 생성될 때 마다

클래스 변수 초기화 > 인스턴스 변수 초기화

자동 초기화(0) > 간단 초기화(=) > 복잡 초기화({}, static {})

## 상속

기존의 클래스로 새로운 클래스를 작성하는 것(코드의 재사용)

두 클래스를 부모와 자식으로 관계를 맺어주는 것

```aidl
class 부모 클래스 {
    타입 값1;
}
class 자식 클래스 extends 부모 클래스 {
    // 자식 클래스는 부모 클래스로부터 상속
    // 타입 값1;
    타입 값2;
}
```

자손은 조상의 모든 멤버를 상속받는다(생성자, 초기화 블럭 제외)

자손의 멤버 개수는 조상보다 적을 수 없다(같거나 많다)

자손의 변경은 조상에 영향을 미치지 않는다

## 포함 관계

포함 = 클래스의 멤버로 참조 변수를 선언하는 것

```aidl
class 클래스1 {
    타입 값1;
}
class 클래스2 { // 클래스2는 클래스1을 포함
    클래스1 참조 변수 = new 클래스1();
    타입 값2;
}
```

## 클래스 간의 관계 설정하기

대부분 포함 관계, 상속은 제약이 있어서 꼭 필요한 경우만 사용

## 단일 상속

하나의 부모로부터 상속 가능

다중 상속 = 비중이 높은 클래스 하나를 상속으로 나머지는 포함

## Object 클래스 - 모든 클래스의 조상

부모가 없는 클래스는 자동으로 Object 클래스를 상속 받음

모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속 받음

## 오버라이딩(overriding)

상속받은 조상의 메서드를 자신에 맞게 변경

```aidl
class 클래스1 {
    타입 값1;
    타입 값2;
    
    반환 타입 메서드1() {
        return '값1'+값1+'값2'+값2;
    }
}
class 클래스2 {
    타입 값3;
    
    반환 타입 메서드1() {
    return '값1'+값1+'값2'+값2+'값3'+값3;
    }
}
```

구현부만 변경 가능, 선언부는 변경 불가

의미상 같은 작업을 수행할 때 적절

## 오버라이딩 조건

선언부가 조상 클래스의 메서드와 일치

접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 불가

예외는 조상 클래스의 메서드보다 많이 선언 불가

## 참조 변수 super

객체 자신을 가리키는 참조 변수, 인스턴스 메서드(생성자) 내에서만 존재

조상의 멤버를 자신의 멤버와 구별할 때 사용

## super() 조상의 생성자

조상의 생성자를 호출할 때 사용

조상의 멤버는 조상의 생성자를 호출해서 초기화

```aidl
class 부모 클래스 {
    타입 값1, 값2;
    
    생성자1 (타입 값1, 타입 값2) {
        this.값1 = 값1;
        this.값2 = 값2;
    }
}

class 자식 클래스 extends 부모 클래스 {
    타입 값3;
    
    생성자2 (타입 값1, 타입 값2, 타입 값3) {
        super(값1, 값2); // 조상 클래스 생성자 생성자1 호출 
        this.값3 = 값3;
    }
}
```

모든 생성자는 첫 줄에 다른 생성자를 호출

그렇지 않으면 컴파일러가 생성자 첫 줄에 super(); 를 삽입

## 패키지(package)

서로 관련된 클래스 묶음

클래스 = 클래스 파일, *.class

패키지 = 폴더, 클래스의 실제 이름은 패키지를 포함

패키는 소스파일의 첫 번째 문장으로 단 한 번 선언

패키지 선언 = `package 패키지 이름;`

같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다

패키지 선언이 없으면 이름없는(unnamed) 패키지에 속하게 된다 

## 클래스 패스(classpath)

클래스 파일의 위치를 알려주는 경로

환경변수로 classpath 로 관리하며 경로간의 구분자는 ';'를 사용

classpath(환경변수)에 패키지의 루트를 등록해줘야 함

## import 문

클래스를 사용할 때 패키지 이름을 생략할 수 있다

컴파일러에게 클래스가 속한 패키지를 알려준다

java.lang 패키지는 import 하지 않아도 사용 가능

import 문 = `import 패키지명.클래스명;`

import 문은 패키지문과 클래스 선언 사이에 선언

import 문은 컴파일 시에 처리되므로 프로그램의 성능에 영향 없음

## static import 문

static 멤버를 사용할 때 클래스 이름을 생략 가능

`import static 패키지명.클래스명;`

## 제어자(modifier)

클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여

하나의 대상에 여러 제어자 사용 가능(접근 제어자는 하나만)

## static -클래스의 , 공통적인

### static 멤버 변수

- 모든 인스턴스에 공통적으로 사용되는 클래스 변수로 변환

- 클래스 변수는 인스턴스를 생성하지 않고 사용 가능

- 클래스가 메모리에 로드될 때 생성

### static 메서드

- 인스턴스 생성하지 않고 호출 가능

- static 메서드 안에서 인스턴스 멤버 직접 사용 불가

## final - 마지막의, 변경 불가

### final 클래스

- 변경 불가, 확장 불가, 다른 클래스에 상속 불가

### final 메서드

- 변경 불가, 오버라이딩 통해 재정의 불가

### final 멤버 변수, final 지역 변수

- 값을 변경할 수 없는 상수로 변환

## abstract - 추상의, 미완성의

abstract 클래스 = 클래스 내에 추상 메서드가 선언 되있음을 알림

abstract 메서드 = 선언부만 작성한 추상 메서드임을 알림

```aidl
abstract class 클래스1 {
    abstract 반환 타입 메서드1();
} 
```

추상 클래스는 인스턴스 생성 불가

추상 클래스를 상속 받아 완전한 클래스를 만든 후 인스턴스 생성 가능

## 접근 제어자

private = 같은 클래스 내에서만 접근 가능

(default) = 같은 패키지 내에서만 접근 가능

protected = 같은 패키지 내에서, 다른 패키지의 자손 클래스에서 접근 가능

public = 접근 제한 없음

public > protected > (default) > private

class = public or (default)

## 캡슐화와 접근 제어자

## 접근 제어자 사용 이유

- 외부로부터 데이터 보호하기 위해

- 외부에는 불필요한 내부적으로만 사용되는 부분들을 감추기 위해

접근 제어자가 public 일 경우 직접 접근 가능

인스턴스 변수 보호를 위해 public 메서드를 통한 간접 접근

## 다형성(polymorphism)

조상 타입 참조 변수로 자손 타입 객체를 다루는 것

```aidl
// 타입 불일치
조상 타입 참조 변수 = new 자손 인스턴스();
```

자손 타입의 참조 변수로 조상 타입의 객체를 가리킬 수 없다

```aidl
class 클래스1 {
    메서드1 () {
        System.out.println("메서드1");
    }
}

class 클래스2 extends 클래스1 {
    메서드2 () {
        System.out.println("메서드2");
    }
}

class main {
    public static void main(String args[]) {
        클래스1 참조 변수1 = new 클래스2();
        클래스1.메서드1(); // 가능
        클래스1.메서드2(); // 불가능
    }
}
```

## 참조 변수의 형변환

사용할 수 있는 멤버의 개수를 조절하는 것

조상 자손 관계의 참조 변수는 서로 형변환 가능

```aidl
class 클래스1 {맴버 4개}
class 클래스2 extends 클래스1 {맴버 5개}
class 클래스3 extends 클래스1 {}

// 사용 가능 맴버 5개
클래스2 참조 변수1 = new 클래스2();

// 조상인 클래스1 타입으로 형변환, 생략 가능, 사용 가능 맴버 4개 
// 클래스1 참조 변수2 = (클래스1)참조 변수1;
클래스1 참조 변수2 = 참조 변수1;

// 자손인 클래스2 타입으로 형변환, 생략 불가, 사용 가능 맴버 5개
클래스2 참조 변수3 = (클래스2)참조 변수2;

// 상속관계가 아닌 클래스 간의 형변화 불가
클래스3 참조 변수4 = (클래스3)참조 변수1;
```

```aidl
클래스1 참조 변수1 = null;
클래스2 참조 변수2 = new 클래스2();

// 조상 > 자손 형변환
클래스2 참조 변수3 = (클래스2)참조 변수1();

// 자손 > 조상 형변환
클래스1 참조 변수4 = (클래스1)참조 변수3()
```

에러가 발생 여부는 인스턴스가 무엇인지가 결정

## instanceof 연산자

참조 변수의 형변환 가능여부 확인에 사용, 가능하면 true 반환

형변환 전에 반드시 확인

`자손 instanceof 조상`

## 매개변수의 다형성

참조형 매개변수는 메서드 호출 시 자신과 같은 타입 또는 자손 타입의 인스턴스를 넘겨줄 수도 있다

`조상 클래스 참조 변수 = new 자손 인스턴스();`

## 여러 종류의 객체를 배열로 다루기

조상 타입의 배열에 자손들의 객체를 담을 수 있다

```aidl
조상 클래스 참조 배열[] = new 조상 인스턴스[3];
참조 배열[0] = new 자손 인스턴스1();
참조 배열[1] = new 자손 인스턴스2();
참조 배열[3] = new 자손 인스턴스3();
```

## 추상 클래스(abstract class)

미완성 메서드를 갖고 있는 클래스

다른 클래스 작성에 도움을 주기 위한 것, 인스턴스 생성 불가

상속을 통해 추상 메서드를 완성해야 인스턴스 생성 가능

꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우

## 추상 메서드

미완성 메서드, 구현부가 없는 메서드

`abstract 반환 타입 메서드 이름();`

꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우에 사용

```aidl
abstract class 클래스1 { // 추상 클래스
    // 추상 메서드 2개
    abstract 리턴반환  메서드1();
    abstract 리턴반환  메서드2();
}

class 클래스2 extends 클래스1 { // 완전한 클래스
    // 부모 클래스의 모든 추상 메서드 구현 완료
    반환 타입 메서드1() { 구현 }
    반환 타입 메서드2() { 구현 }
}

abstract class 자식 클래스 extends 부모 클래스 { // 불완전한 클래스
    // 부모 클래스의 모든 추상 메서드를 구현하지 않음
    반환 타입 메서드1() { 구현 }
}
```

추상 메서드 호출 가능, 호출엔 선언부만 필요

## 추상 클래스의 작성

여러 클래스에 공통적으로 사용될 수 있는 추상 클래스를 바로 작성하거나 기존 클래스의 공통 부분을 뽑아서 추상 클래스를 만든다

추상화된 코드는 구체화된 코드보다 유연하다

## 인터페이스

추상 메서드의 집합

모든 상수 = public  static final, 일부 또는 전부 생략 가능

모든 메서드 = public abstract, 일부 또는 전부 생략 가능

```aidl
interface 인터페이스 이름 {
    // public abstract 생략 가능
    // 메서드 이름(매개변수 목록);
    public abstract 메서드 이름(매개변수 목록);
}
```

## 인터페이스의 상속

인터페이스의 조상은 인터페이스만 가능(Object가 최고 조상 아님)

다중 상속 가능, 추상 메서드는 충돌해도 상관 없음

```aidl
interface 인터페이스1 extends 인터페이스2, 인터페이스3 {}

interface 인터페이스2 {
    반환 타입 메서드1 {}
}

interface 인터페이스3 {
    반환 타입 메서드2 {}
}
```

## 인터페이스의 구현

인터페이스에 정의된 추상 메서드를 완성하는 것

```aidl
class 클래스 이름 implements 인터페이스 이름{
    // 인터페이스의 정의된 메서드 모두 구현
}
```

추상 클래스를 상속받아 완성하는 것과 동일

일부만 구현하는 경우 class 앞에 abstract

인터페이스는 인스턴스 변수를 가질 수 없다

## 인터페이스를 이용한 다형성

인터페이스 타입 매개변수는 인터페이스 구현한 클래스의 인스턴스만 가능

```aidl
class 클래스1 extends 클래스2 implements 인터페이스 {
    public 반환 타입 메서드1() {}
}
```

인터페이스를 메서드의 반환 타입으로 지정할 수 있다

반환 타입이 인터페이스면 인터페이스를 구현한 인스턴스를 반환해야 한다

반환타입이 인터페이스인 메서들르 호출했을 경우 타입이 일치해야 한다

